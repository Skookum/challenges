// Generated by CoffeeScript 1.3.3
(function() {
  var areNeighbors, dictFile, dictionary, expandPath, findPath, fs, loadArgs, loadDictionary, possibleMoves, solution, step, words, _i, _len, _ref;

  fs = require('fs');

  dictionary = [];

  loadArgs = function() {
    var args;
    args = process.argv;
    if (args.length < 5) {
      console.log("\nsyntax:\n\n    coffee hunter.coffee <dictionary> <word1> <word2>");
      process.exit();
    }
    return [args[2], [args[3].toLowerCase(), args[4].toLowerCase()]];
  };

  loadDictionary = function(file, length) {
    var word, words;
    words = fs.readFileSync(file, 'utf-8').toLowerCase().split('\n');
    return dictionary = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = words.length; _i < _len; _i++) {
        word = words[_i];
        if (word.length === length) {
          _results.push(word);
        }
      }
      return _results;
    })();
  };

  possibleMoves = function(source) {
    var i, moves;
    moves = [];
    i = 0;
    while (i < dictionary.length) {
      if (areNeighbors(dictionary[i], source)) {
        moves.push(dictionary[i]);
        dictionary.splice(i, 1);
      } else {
        i++;
      }
    }
    return moves;
  };

  areNeighbors = function(a, b) {
    var diff, i, _i, _ref;
    diff = 0;
    for (i = _i = 0, _ref = a.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      if (a[i] !== b[i] && ++diff === 2) {
        return false;
      }
    }
    return diff === 1;
  };

  expandPath = function(path) {
    var move, moves, subpaths;
    moves = possibleMoves(path[path.length - 1]);
    subpaths = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = moves.length; _i < _len; _i++) {
        move = moves[_i];
        _results.push(path.concat(move));
      }
      return _results;
    })();
    return subpaths;
  };

  findPath = function(dest, paths) {
    var newPaths, path, _i, _j, _len, _len1;
    for (_i = 0, _len = paths.length; _i < _len; _i++) {
      path = paths[_i];
      if (path[path.length - 1] === dest) {
        return path;
      }
    }
    newPaths = [];
    for (_j = 0, _len1 = paths.length; _j < _len1; _j++) {
      path = paths[_j];
      newPaths = newPaths.concat(expandPath(path));
    }
    if (newPaths.length === 0) {
      return void 0;
    }
    return findPath(dest, newPaths);
  };

  _ref = loadArgs(), dictFile = _ref[0], words = _ref[1];

  loadDictionary(dictFile, words[0].length);

  solution = findPath(words[1], [[words[0]]]);

  if (solution) {
    for (_i = 0, _len = solution.length; _i < _len; _i++) {
      step = solution[_i];
      console.log(step);
    }
  } else {
    console.log('sorry, there is no chain between "' + words[0] + '" and "' + words[1] + '"');
  }

}).call(this);
